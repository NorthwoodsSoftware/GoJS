<!DOCTYPE html>
<html>
<head>
  <title>Arranging Layout of the Class Hierarchy</title>
  <!-- Copyright 1998-2021 by Northwoods Software Corporation. -->
  <meta name="description" content="Arrange disconnected circular subgraphs in a circle and put disconnected nodes in a grid underneath." />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="../assets/js/goSamples.js"></script> <!-- this is only for the GoJS Samples framework -->
</head>
<body>
<div id="sample">
  <div id="myDiagramDiv" style="border: solid 1px black; width:100%; height:800px; min-width: 200px"></div>
  <p>
    This sample demonstrates a custom Layout, <a>ArrangingLayout</a>, that provides layouts of layouts.
    It assumes the graph should be split up and laid out by potentially three separate Layouts.
  </p>
  <p>
    The first step of ArrangingLayout is that all unconnected nodes are separated out to be laid out later by
    the <a>ArrangingLayout.sideLayout</a>, which by default is a <a>GridLayout</a>.
  </p>
  <p>
    The remaining nodes and links are partitioned into separate subgraphs with no links between subgraphs.
    The <a>ArrangingLayout.primaryLayout</a> is performed on each subgraph.
  </p>
  <p>
    If there is more than one subgraph, those subgraphs are treated as if they were individual nodes and are
    laid out by the <a>ArrangingLayout.arrangingLayout</a>.
  </p>
  <p>
    Finally the unconnected nodes are laid out by <a>ArrangingLayout.sideLayout</a> and they are all positioned
    at the <a>ArrangingLayout.side</a> Spot relative to the main body of nodes and links.
  </p>
  <p>
    This extension layout is defined in its own file, as <a href="ArrangingLayout.js">ArrangingLayout.js</a>.
  </p>
  <script type="module" id="code">
    import * as go from "../release/go-module.js";
    import { ArrangingLayout } from "./ArrangingLayout.js";
    import { PackedLayout } from "./PackedLayout.js";

    if (window.goSamples) goSamples();  // init for these samples -- you don't need to call this
    var $ = go.GraphObject.make;

    const myDiagram =
      $(go.Diagram, "myDiagramDiv",  // create a Diagram for the DIV HTML element
        {
          initialAutoScale: go.Diagram.Uniform,
          layout:
            $(ArrangingLayout,
              { // create a circular arrangement of circular layouts
                primaryLayout: $(go.CircularLayout),  // must specify the primaryLayout
                arrangingLayout: $(go.CircularLayout, { nodeDiameterFormula: go.CircularLayout.Circular, spacing: 30 }),

                // Uncommenting this filter will force all of the nodes and links to go into the main subset and thus
                // will cause all those nodes to be arranged by this.arrangingLayout, here a CircularLayout,
                // rather than by the this.sideLayout, which by default is a GridLayout.
                //filter: function(part) { return true; },

                // additional custom properties for use by preparePrimaryLayout
                _colors: ["red", "orange", "yellow", "lime", "cyan"],  // possible node colors
                _colorIndex: 0,  // cycle through the given colors

                // called for each separate connected subgraph
                preparePrimaryLayout: function(lay, coll) {  // color all of the nodes in each subgraph
                  var root = null;  // find the root node in this subgraph
                  coll.each(function(node) {
                    if (node instanceof go.Node && node.findLinksInto().count === 0) root = node;
                  });
                  var color = "white";  // determine the color for the nodes in this subgraph
                  if (root !== null) {
                    // root.key will be the name of the class that this node represents
                    // Special case: "LayoutNetwork", "LayoutVertex", and "LayoutEdge" classes are "violet"
                    if (root.key.indexOf("Layout") === 0 && root.key.length > "Layout".length) {
                      color = "violet";
                    } else {  // otherwise cycle through the Array of colors
                      color = this._colors[this._colorIndex++ % this._colors.length];
                    }
                  }
                  coll.each(function(node) {  // assign the fill color for all of the nodes in the subgraph
                    if (node instanceof go.Node) {
                      var shape = node.findObject("SHAPE");
                      if (shape !== null) shape.fill = color;
                    }
                  });
                },

                prepareSideLayout: function(lay, coll, b) {  // called once for the sideLayout
                  // adjust how wide the GridLayout lays out
                  lay.wrappingWidth = Math.max(b.width, this.diagram.viewportBounds.width);
                }
              })
        });

    myDiagram.nodeTemplate =
      $(go.Node, go.Panel.Auto,
        $(go.Shape, { name: "SHAPE", figure: "RoundedRectangle", fill: "lightgray" },
          new go.Binding("fill", "color")),
        $(go.TextBlock, { margin: 2, textAlign: "center" },
          new go.Binding("text", "key", function(s) {
            // insert newlines between lowercase followed by uppercase characters
            var arr = s.split("");
            for (let i = 1; i < arr.length-1; i++) {
              var a = arr[i-1];
              var b = arr[i];
              if (a === a.toLowerCase() && b === b.toUpperCase()) {
                arr.splice(i, 0, "\n");
                i += 2;
              }
            }
            return arr.join("");
          })));

    myDiagram.linkTemplate =
      $(go.Link,
        { layerName: "Background" },
        $(go.Shape));

    // Collect all of the data for the model of the class hierarchy
    var nodeDataArray = [];

    // Iterate over all of the classes in "go"
    for (var k in go) {
      var cls = go[k];
      if (!cls) continue;
      var proto = cls.prototype;
      if (!proto) continue;
      proto.constructor.className = k;  // remember name
      // find base class constructor
      var base = Object.getPrototypeOf(proto).constructor;
      if (base === Object) {  // "root" node?
        nodeDataArray.push({ key: k });
      } else {
        // add a node for this class and a tree-parent reference to the base class name
        nodeDataArray.push({ key: k, parent: base.className });
      }
    }

    // Create the model for the hierarchy diagram
    myDiagram.model = new go.TreeModel(nodeDataArray);
    window.myDiagram = myDiagram; // Attach to the window for console debugging
  </script>
</div>
</body>
</html>
