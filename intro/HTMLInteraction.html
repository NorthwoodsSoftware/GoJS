
<h1>HTML Interaction</h1>

<p>
  This intro page explains how to use GoJS Diagrams alongside other HTML elements in a webapp.
</p>

<p>
  For custom Text Editors, Context Menus, and ToolTips, which are invoked and hidden via GoJS tool operations, it is best to use the <a>HTMLInfo</a> class.
  <code>HTMLInfo</code> is described in the second section of this page.
</p>

<h2 id="UsingHTMLAlongsideGoJS">Using HTML Alongside GoJS</h2>

<h3 id="EditingPartsWithHTMLDataInspector">Editing Parts with the HTML Data Inspector</h3>

<p>
  Generally, GoJS can interact with the rest of the page via JavaScript that programmatically moves and modifies GoJS objects and the Diagram. If you have not
  read about programmatically interacting with Parts and the Model, there is a
  <a href="../learn/graphObject.html">GraphObject Manipulation tutorial</a> for this purpose.
</p>

<p>
  To help programmers get started with HTML controls we have implemented a simple <a href="../samples/DataInspector.html">Data Inspector Extension</a>, an
  HTML-based property editor that displays and allows editing of data for the selected Part.
</p>

<p>
  The Data Inspector chiefly works via a <code>"ChangedSelection"</code> <a href="events.html">Diagram Listener</a>. When triggered, it populates HTML Fields.
  Editing those fields and clicking away then update the selected Part by calling <code>diagram.model.setDataProperty</code> to update the model.
</p>

<h3 id="JQueryAndGoJS">jQuery and GoJS</h3>

<p>
  GoJS does not depend on jQuery, but the two can be used together. The <a href="../samples/htmlInteraction.html">HTML Interaction Sample</a> places a GoJS
  Palette inside of a jQuery movable window, and a data inspector that modifies the current selected node inside another.
</p>

<p>
  jQuery normally sets the <code>$</code> variable.
  Our samples no longer make use of <a>GraphObject.make</a>,
  which was frequently abbreviated by using the <code>$</code> const,
  so the chances of conflict are reduced.
</p>

<h3 id="HTMLFocusOnDiagrams">HTML Focus on Diagrams</h3>

<p>
  When a browser element gets focus, some browsers scroll that element into view as much as possible. Because this behavior may be unwelcome in some web apps,
  the <a>Diagram.scrollsPageOnFocus</a> property defaults to false. However you may want to set this property to true in order to get the standard behavior.
</p>

<p>
  You can remove the outline while the Diagram is in focus. This is a CSS effect, not a GoJS effect, and can be removed by removing the CSS outline from all
  HTML elements inside the Diagram div:
</p>

<pre class="lang-css"><code>/* affect all elements inside myDiagramDiv */
#myDiagramDiv * {
  outline: none;
  -webkit-tap-highlight-color: rgba(255, 255, 255, 0); /* mobile webkit */
}
</code></pre>

<h2 id="HTMLInfoClass">The HTMLInfo Class</h2>
<p>
  Use the <a>HTMLInfo</a> class to display custom HTML page elements, such as a context menu, tooltip, or text editor made of HTML.
</p>

<p>
  Properties that can be set to an instance of <code>HTMLInfo</code> include:
</p>

<ul>
  <li><a>TextEditingTool.defaultTextEditor</a></li>
  <li><a>TextBlock.textEditor</a></li>
  <li><a>GraphObject.contextMenu</a></li>
  <li><a>Diagram.contextMenu</a></li>
  <li><a>GraphObject.toolTip</a></li>
  <li><a>Diagram.toolTip</a></li>
</ul>

<h3 id="Usage">Usage</h3>

<p>
  When replacing GoJS functionality with custom functionality, the main concern is when to show and hide the custom content. <code>HTMLInfo</code> does this
  with two settable functions defined by the programmer and called by GoJS:
</p>

<ul>
  <li>
    <a>HTMLInfo.show</a>, called by GoJS when custom information should be displayed, for example when activating a ToolTip, ContextMenuTool, or
    TextEditingTool.
  </li>

  <li><a>HTMLInfo.hide</a>, called by GoJS when custom information is finished, and should no longer be displayed, for example when ending these tools.</li>
</ul>

<p>
  In lieu of setting <a>HTMLInfo.hide</a>, you can set the <a>HTMLInfo.mainElement</a> property to the primary HTML Element that you are showing/hiding, and
  HTMLInfo will automatically hide the provided element by calling:
</p>

<pre class="lang-js"><code>mainElement.style.display = "none";</code></pre>

<h3 id="HTMLInfoSamples">HTMLInfo samples</h3>

<ul>
  <li>
    Text Editors: <a href="../samples/customTextEditingTool.html">Custom Text Editors sample</a> and
    <a href="../samples/TextEditor.html">Re-implementation of the default Text Editor</a>
  </li>

  <li>
    Context Menus: <a href="../samples/customContextMenu.html">Custom Context Menu</a> and
    <a href="../samples/htmlLightBoxContextMenu.html">HTML Lightbox Context Menu</a> (a re-implementation of the default touch context menu)
  </li>

  <li>Tooltips: <a href="../samples/dataVisualization.html">Data Visualization Tooltip</a></li>
</ul>

<h3 id="Tooltips">Tooltips</h3>

<p>
  For tooltips, if a <a>GraphObject.toolTip</a> or <a>Diagram.toolTip</a> is set to an instance of <code>HTMLInfo</code>, GoJS calls
  <code>HTMLInfo.show</code> in <a>ToolManager.showToolTip</a>. After the tooltip delay, GoJS will call <code>HTMLInfo.hide</code> in
  <a>ToolManager.hideToolTip</a>.
</p>

<p>
  What follows is an example using <code>HTMLInfo.show</code> and <code>HTMLInfo.hide</code>, but the <code>HTMLInfo.hide</code> is simple enough that setting
  the <code>HTMLInfo.mainElement</code> to the tooltip div instead would be sufficient.
</p>

<div id="diagramParent" style="position: relative">
  <div id="toolTipDIV" style="position: absolute; background: white; z-index: 1000; display: none">
    <p id="toolTipParagraph">Tooltip</p>
  </div>
</div>

<pre class="lang-js" id="toolTipExample"><code>
  function showToolTip(obj, diagram, tool) {
    const toolTipDIV = document.getElementById('toolTipDIV');
    const pt = diagram.lastInput.viewPoint;
    toolTipDIV.style.left = (pt.x + 10) + "px";
    toolTipDIV.style.top = (pt.y + 10) + "px";
    document.getElementById('toolTipParagraph').textContent = "Tooltip for: " + obj.data.text;
    toolTipDIV.style.display = "block";
  }

  function hideToolTip(diagram, tool) {
   const toolTipDIV = document.getElementById('toolTipDIV');
   toolTipDIV.style.display = "none";
  }

  const myToolTip = new go.HTMLInfo({
    show: showToolTip,
    hide: hideToolTip
    /*
      since hideToolTip is very simple,
      we could have set mainElement instead of setting hide:
    mainElement: document.getElementById('toolTipDIV')
    */
  });

  diagram.nodeTemplate =
    new go.Node("Auto", { toolTip: myToolTip })
      .add(
        new go.Shape("RoundedRectangle", { strokeWidth: 0})
          .bind("fill", "color"),
        new go.TextBlock({ margin: 8 })
          .bind("text")
      );

  diagram.model = new go.GraphLinksModel(
  [
    { text: "Alpha", color: "lightblue" },
    { text: "Beta", color: "orange" },
    { text: "Gamma", color: "lightgreen" },
    { text: "Delta", color: "pink" }
  ]);
</code></pre>

<pre class="lang-html"><code>
  &lt;!-- this must be added as a sibling of the Diagram --&gt;
  &lt;div id="toolTipDIV" style="position: absolute; background: white; z-index: 1000; display: none;"&gt;
    &lt;p id="toolTipParagraph"&gt;Tooltip&lt;/p&gt;
  &lt;/div&gt;
</code></pre>

<script>
  goCode('toolTipExample', 600, 160, 'diagramParent');
</script>

<h3 id="ContextMenus">Context Menus</h3>

<p>
  For context menus, <a>ContextMenuTool.showContextMenu</a> will call <code>HTMLInfo.show</code>. <a>ContextMenuTool.hideContextMenu</a> will call
  <code>HTMLInfo.hide</code>.
</p>

<pre class="lang-js"><code>// Assign an HTMLInfo to the Diagram:
myDiagram.contextMenu = new go.HTMLInfo({
  show: showContextMenu,
  hide: hideContextMenu
});

function showContextMenu(obj, diagram, tool) {
  // Show the context menu HTML element:
  SomeDOMElement.style.display = "block";

  // Also show relevant buttons given the current state
  // and the GraphObject obj; if null, the context menu is for the whole Diagram
}

function hideContextMenu() {
  SomeDOMElement.style.display = "none";
}

function buttonClick() {
  // do some action when a context menu button is clicked

  // then:
  myDiagram.currentTool.stopTool();
}
</code></pre>

<h3 id="TextEditors">Text Editors</h3>

<p>
  For custom text editors, <a>TextEditingTool.doActivate</a> will call <code>HTMLInfo.show</code>. <a>TextEditingTool.doDeactivate</a> will call
  <code>HTMLInfo.hide</code>.
</p>

<p>
  HTMLInfos used as text editors must also define a <a>HTMLInfo.valueFunction</a>. When <a>TextEditingTool.acceptText</a> is called, GoJS will call
  <code>HTMLInfo.valueFunction</code> and use the return value as the value for the TextEditingTool completion.
</p>

<p>
  The example below constructs an HTMLInfo that uses <code>HTMLInfo.show</code> and <code>HTMLInfo.hide</code> to dynamically add, populate, and remove HTML
  elements from the page.
</p>

<div id="diagramParent2" style="position: relative"></div>
<pre class="lang-js" id="textEditorExample"><code>
// Diagram setup. The HTMLInfo is set at the end of this code block.
diagram.nodeTemplate =
  new go.Node("Auto")
    .add(
      new go.Shape("RoundedRectangle", { strokeWidth: 0})
        .bind("fill", "color"),
      new go.TextBlock({
          editable: true,
          margin: 8,
          choices: ['Alpha', 'Beta', 'Gamma', 'Delta']
        })
        .bind("text")
    );

diagram.model = new go.GraphLinksModel(
[
  { text: "Alpha", color: "lightblue" },
  { text: "Beta",  color: "orange" },
  { text: "Gamma", color: "lightgreen" },
  { text: "Delta", color: "pink" }
]);

// Create an HTMLInfo and dynamically create some HTML to show/hide
const customEditor = new go.HTMLInfo();
const customSelectBox = document.createElement("select");

customEditor.show = (textBlock, diagram, tool) => {
  if (!(textBlock instanceof go.TextBlock)) return;
  customSelectBox.style.background = 'white';
  // Populate the select box:
  customSelectBox.innerHTML = "";

  // this sample assumes textBlock.choices is not null
  const list = textBlock.choices;
  for (let i = 0; i < list.length; i++) {
    const op = document.createElement("option");
    op.text = list[i];
    op.value = list[i];
    customSelectBox.add(op, null);
  }

  // After the list is populated, set the value:
  customSelectBox.value = textBlock.text;

  // Do a few different things when a user presses a key
  customSelectBox.addEventListener("keydown", e => {
    if (e.isComposing) return;
    const key = e.key;
    if (key === "Enter") { // Accept on Enter
      tool.acceptText(go.TextEditingAccept.Enter);
      return;
    } else if (key === "Tab") { // Accept on Tab
      tool.acceptText(go.TextEditingAccept.Tab);
      e.preventDefault();
      return false;
    } else if (key === "Escape") { // Cancel on Esc
      tool.doCancel();
      if (tool.diagram) tool.diagram.focus();
    }
  }, false);

  const loc = textBlock.getDocumentPoint(go.Spot.TopLeft);
  const pos = diagram.transformDocToView(loc);
  customSelectBox.style.left = pos.x + "px";
  customSelectBox.style.top  = pos.y + "px";
  customSelectBox.style.position = 'absolute';
  customSelectBox.style.zIndex = 100; // place it in front of the Diagram

  diagram.div.appendChild(customSelectBox);
  customSelectBox.focus();
}

customEditor.hide = (diagram, tool) => {
  diagram.div.removeChild(customSelectBox);
}

// This is necessary for HTMLInfo instances that are used as text editors
customEditor.valueFunction = () => customSelectBox.value;

// Set the HTMLInfo:
diagram.toolManager.textEditingTool.defaultTextEditor = customEditor;

</code></pre>
<script>
  goCode('textEditorExample', 600, 160, 'diagramParent2');
</script>
