
<h1>Palette Diagrams</h1>
<p>
  A <a>Palette</a> is a subclass of <a>Diagram</a> that is used to display a number of <a>Part</a>s that can be dragged into the diagram that is being modified
  by the user. The initialization of a <a>Palette</a> is just like the initialization of any <a>Diagram</a>. Like Diagrams, you can have more than one Palette
  on the page at the same time.
</p>
<p>See samples that make use of <a>Palette</a>s in the <a href="../samples/index.html#palette">samples index</a>.</p>
<p>
  The following code initializes an empty Diagram on the right side, below. Note that <a>Diagram.allowDrop</a> must be true, which it is now by default. In this
  example we do not bother initializing the model with any node data.
</p>
<p>
  This code also creates two <a>Palette</a>s, in the same manner as you would any Diagram. You initialize a Palette's model in order to show nodes in that
  Palette.
</p>
<pre class="lang-js" id="diagramPre"><code>
  diagram.nodeTemplate =
    new go.Node("Auto")
      .add(
        new go.Shape("RoundedRectangle", {
            fill: "white",
            portId: "", fromLinkable: true, toLinkable: true, cursor: "pointer"
          })
          .bind("fill", "color"),
        new go.TextBlock({ margin: 5 })
          .bind("text", "color")
      );

  diagram.undoManager.isEnabled = true;

  // create the Palette
  const myPalette =
    new go.Palette("myPaletteDiv");

  // the Palette's node template is different from the main Diagram's
  myPalette.nodeTemplate =
    new go.Node("Horizontal")
      .add(
        new go.Shape({ width: 14, height: 14, fill: "white" })
          .bind("fill", "color"),
        new go.TextBlock({ margin: 2 })
          .bind("text", "color")
      );

  // the list of data to show in the Palette
  myPalette.model.nodeDataArray = [
    { key: "C", color: "cyan" },
    { key: "LC", color: "lightcyan" },
    { key: "A", color: "aquamarine" },
    { key: "T", color: "turquoise" },
    { key: "PB", color: "powderblue" },
    { key: "LB", color: "lightblue" },
    { key: "LSB", color: "lightskyblue" },
    { key: "DSB", color: "deepskyblue" }
  ];

  // create the Palette
  const myPalette2 =
    new go.Palette("myPaletteDiv2",
      { // customize the GridLayout to align the centers of the locationObjects
        layout: new go.GridLayout({ alignment: go.GridAlignment.Location })
      });

  // the Palette's node template is different from the main Diagram's
  myPalette2.nodeTemplate =
    new go.Node("Vertical", {
        locationObjectName: "TB", locationSpot: go.Spot.Center
      })
      .add(
        new go.Shape({ width: 20, height: 20, fill: "white" })
          .bind("fill", "color"),
        new go.TextBlock({ name: "TB" })
          .bind("text", "color")
      );

  // the list of data to show in the Palette
  myPalette2.model.nodeDataArray = [
    { key: "IR", color: "indianred" },
    { key: "LC", color: "lightcoral" },
    { key: "S", color: "salmon" },
    { key: "DS", color: "darksalmon" },
    { key: "LS", color: "lightsalmon" }
  ];
</code></pre>
<div style="width: 100%">
  <span id="paletteSpan" style="display: inline-block; vertical-align: top">
    <b>Palette 1 (blues):</b><br />
    <div id="myPaletteDiv" style="width: 120px; height: 250px" class="diagramStyling"></div>
  </span>
  <span id="diagramSpan" style="display: inline-block; vertical-align: top"> <b>Diagram:</b><br /> </span>
  <span id="paletteSpan2" style="display: inline-block; vertical-align: top">
    <b>Palette 2 (reds):</b><br />
    <div id="myPaletteDiv2" style="width: 120px; height: 250px" class="diagramStyling"></div>
  </span>
</div>
<script>
  goCode('diagramPre', 250, 250, 'diagramSpan');
</script>
<p>
  First, notice that although both Palettes have been initialized with the same kind of model data, the appearances of the items in the palettes are different
  because the two use different node templates.
</p>
<p>
  Furthermore when you drag a part from the Palette on either side into the Diagram in the middle, that the appearance changes, because the main (target)
  Diagram uses a third node template.
  <em>What is being dragged is just the model data, not the actual <a>Node</a>s.</em>
  Because each diagram can use its own templates, the same data object can be represented completely differently.
</p>
<p>If you want the Palette to show exactly the same Nodes for the same data as your main Diagram, you can have it share the templates of the main Diagram:</p>
<pre class="lang-js"><code>
  myPalette.nodeTemplateMap = myDiagram.nodeTemplateMap;
</code></pre>
<p>
  Because <a>Palette</a> inherits from <a>Diagram</a>, you can customize it in the normal manners. You can decide to set its <a>Diagram.initialScale</a> if you
  want its parts to be smaller or larger than normal.
</p>
<p>
  It is also commonplace to customize the ordering of the parts in the palette. The palette's layout property is a <a>GridLayout</a>, so you can set its
  <a>GridLayout.sorting</a> property, and if needed, its <a>GridLayout.comparer</a> property to a custom sorting function. For example, if you want the Palette
  to show its parts in exactly the same order in which they appear in the <code>myPalette.model.nodeDataArray</code>:
</p>
<pre class="lang-js"><code>
  myPalette.layout.sorting = go.GridSorting.Forwards;
</code></pre>
<p>If you wanted to sort the parts in the Palette according to some property on the model data:</p>
<pre class="lang-js"><code>
  myPalette.layout.comparer = (a, b) => {
      // A and B are Parts
      const av = a.data.someProp;
      const bv = b.data.someProp;
      if (av < bv) return -1;
      if (av > bv) return 1;
      return 0;
    };
</code></pre>
