
<h1>Pictures</h1>
<p>
  Use the <a>Picture</a> class to display images. The most common usage is to set the <a>Picture.source</a> property with a URL string, along with the
  <a>GraphObject.desiredSize</a> or the <a>GraphObject.width</a> and <a>GraphObject.height</a>.
</p>
<p>
  If the URL is just a simple constant string, you can pass the string directly as an argument, rather than assign the "source:" property. Both techniques have
  the same effect.
</p>
<p>
  In these simplistic demonstrations, the code programmatically creates a Part and adds it to the Diagram.
  Once you learn about models and data binding you will generally not create parts (nodes or links) programmatically.
</p>
<pre class="lang-js" id="source"><code>
diagram.add(
  new go.Part()
    .add(
      new go.Picture("images/100x65.png")
    ));
</code></pre>
<script>
  goCode('source', 600, 160);
</script>
<p>However for more sophisticated control you can set the <a>Picture.element</a> to an <b>HTMLImageElement</b> or an <b>HTMLCanvasElement</b>.</p>

<h3 id="SimpleIconsUsingFonts">Simple Icons Using Fonts</h3>
<p>
  Note: for showing simple icons you may want to use an icon font.
  See the example using a <a>TextBlock</a> rather than a <a>Picture</a> at:
  <a href="textBlocks.html#IconFonts">Icon Fonts</a>
</p>

<h2 id="Sizing">Sizing</h2>
<p>
  If you do not set the <a>GraphObject.desiredSize</a> of a <a>Picture</a>, it will get the picture's natural size. But when you set the desiredSize to be
  something different than the natural size, the picture may be stretched or compressed to fit.
</p>
<p>The following pictures all show a picture of kittens that is 100x65 pixels.</p>
<ul>
  <li>The first picture shows the image at its natural size.</li>
  <li>The second picture also shows the image at its natural size, but has its desiredSize set explicitly.</li>
  <li>The third picture increases the size of the Picture, causing the image to be expanded evenly.</li>
  <li>The fourth picture squeezes the 100x65 image into a 50x32.5 space -- half size. This also maintains the original aspect ratio of the image.</li>
  <li>The last picture sets the picture size to be 50x70, which changes the aspect ratio to be taller and thinner than the original.</li>
</ul>
<pre class="lang-js" id="sizedPictures"><code>
const settings = { source: "images/100x65.png", margin: 2 };
diagram.add(
  new go.Part("Table")
    .add(
      new go.Picture(settings)
        .set({ column: 0, /* natural width and height */ }),
      new go.TextBlock("natural", { row: 1, column: 0 }),
      new go.Picture(settings)
        .set({ column: 1, width: 100, height: 65 }),
      new go.TextBlock("same size", { row: 1, column: 1 }),
      new go.Picture(settings)
        .set({ column: 2, width: 200, height: 130 }),
      new go.TextBlock("bigger", { row: 1, column: 2 }),
      new go.Picture(settings)
        .set({ column: 3, width: 50, height: 32.5 }),
      new go.TextBlock("smaller", { row: 1, column: 3 }),
      new go.Picture(settings)
        .set({ column: 4, width: 50, height: 70 }),
      new go.TextBlock("stretched", { row: 1, column: 4 })
    ));
</code></pre>
<script>
  goCode('sizedPictures', 600, 160);
</script>
<p>
  Note that it may take a while for the media to load. Until the time that the media has loaded sufficiently to know its natural size, the Picture may have the
  wrong size, such as 0x0. We recommend that you specify the desiredSize (or width and height) so that the Panel(s) holding the Picture will not have to
  rearrange themselves once the media has loaded.
</p>
<p>However for the times when you cannot know the natural size ahead of time, there are alternative ways of stretching images to fit in a given space.</p>

<h2 id="ImageStretch">Image Stretch</h2>
<p>
  Instead of always stretching or compressing to fill the desiredSize, you can set the <a>Picture.imageStretch</a> property to control the size and aspect ratio
  of the drawn image.
</p>
<p>
  The following pictures demonstrate the four possible values for Picture.imageStretch. All four Pictures here have the size 60x80 and show the same 100x65 PNG
  file. The Pictures also have a light green background, to show the space available that may be left unused, but is still part of the Picture's bounds.
</p>
<ul>
  <li>
    The first picture demonstrates the default behavior, to stretch in both directions. Note how the image is distorted to be narrower than it should be.
    However, all of the image is shown. Because the image fills the whole area and the image is not translucent, the background color does not show anywhere.
  </li>
  <li>
    You can see in the second picture, using an imageStretch of <a>ImageStretch.None</a>, how it only shows a fraction of the whole kitten image. Because the
    desiredSize is smaller than the natural size of the image, parts of the image are clipped.
  </li>
  <li>
    The third picture shows how a <a>ImageStretch.Uniform</a> imageStretch will make sure that all of the image is shown, at the expense of reducing the scale
    and leaving some empty space at the sides or at the top and bottom. In this case, because the natural image aspect ratio is wider than the available 60x80
    aspect ratio, the empty space will be at the top and bottom.
  </li>
  <li>
    The fourth picture shows how a <a>ImageStretch.UniformToFill</a> imageStretch will ensure that the whole area is occupied with image, but that not all of
    the image is shown, since some may be clipped at the sides or at the top and bottom. Such images normally have a larger scale than when using Uniform
    imageStretch. In this case what must be clipped is at the sides of the image.
  </li>
  <li>Finally there is a separate Part containing the original image, sized naturally, for comparison.</li>
</ul>
<pre class="lang-js" id="stretchedPictures"><code>
const settings = { width: 60, height: 80, margin: 2, background: "lime" };
diagram.add(
  new go.Part("Table")
    .add(
      new go.Picture("images/100x65.png", {
          row: 0, column: 0, imageStretch: go.ImageStretch.Fill /* the default value */
        })
        .set(settings),
      new go.TextBlock("Fill", { row: 1, column: 0 }),
      new go.Picture("images/100x65.png", {
          row: 0, column: 1, imageStretch: go.ImageStretch.None
        })
        .set(settings),
      new go.TextBlock("None", { row: 1, column: 1 }),
      new go.Picture("images/100x65.png", {
          row: 0, column: 2, imageStretch: go.ImageStretch.Uniform
        })
        .set(settings),
      new go.TextBlock("Uniform", { row: 1, column: 2 }),
      new go.Picture("images/100x65.png", {
          row: 0, column: 3, imageStretch: go.ImageStretch.UniformToFill
        })
        .set(settings),
      new go.TextBlock("UniformToFill", { row: 1, column: 3 })
    ));

// The original image sized naturally, for comparison
diagram.add(
  new go.Part("Vertical")
    .add(
      new go.Picture("images/100x65.png"),
      new go.TextBlock("Original image,\nsized naturally")
    ));
</code></pre>
<script>
  goCode('stretchedPictures', 600, 120);
</script>
<p>When images are clipped you can control what part of the image is drawn by using the <a>Picture.imageAlignment</a> property.</p>

<h2 id="Clipping">Clipping</h2>
<p>
  If you have a Picture that must be clipped to a geometry, such as to produce a circular image, there are two options.
  The first is to use a "frame" geometry to hide part of the image.
  Typically this frame is the same color as the Diagram background or the background of the Node.
  This method does not change the area of the Picture, does not allow for true transparency,
  and clicking anywhere in the bounds will always pick the picture.
</p>
<p>
  A second method uses <a>Panel.isClipping</a>.
  This property on a "Spot" Panel allows the filled area of the main Shape to serve as a clipping region instead
  of a drawn shape. This method does not change the area of the Picture, but does allow for transparency.
  It affects object picking so that only the resultant drawn area is pickable;
  areas of the image that are not drawn cannot be "hit".
</p>
<p>Examples of both follow:</p>
<pre class="lang-js" id="clipPictures"><code>

diagram.layout = new go.GridLayout();

// Using a black "frame" geometry to hide part of the image.
// Typically this frame is the same color as the Diagram background or the background of the Node.
diagram.add(
  new go.Part("Spot", { scale: 2 })
    .add(
      new go.Picture("../samples/images/55x55.png", {
        width: 55, height: 55,
        background: 'red'
      }),
      new go.Shape({
        width: 55, height: 55,
        geometryString: "f M0 0 L100 0 L100 100 L0 100 z M5,50a45,45 0 1,0 90,0a45,45 0 1,0 -90,0 z",
        fill: 'black', strokeWidth: 0
      })
    )
  );

// Using Panel.isClipping
diagram.add(
  new go.Part("Spot", { scale: 2, isClipping: true })
    .add(
      new go.Shape("Circle", { width: 55, strokeWidth: 0 } ),
      new go.Picture("../samples/images/55x55.png",
          { width: 55, height: 55 })
    )
  );

// Using Panel.isClipping and also having a surrounding border behind it
diagram.add(
  new go.Part("Spot", { scale: 2 })
    .add(
      // the background border
      new go.Shape("Circle", { width: 65, strokeWidth: 0, fill: 'red' } ),
      // the same clipping panel as the second example, above
      new go.Panel("Spot", { isClipping: true })
        .add(
          new go.Shape("Circle", { width: 55, strokeWidth: 0 } ),
          new go.Picture("../samples/images/55x55.png",
              { width: 55, height: 55 })
        )
    )
  );
</code></pre>
<script>
  goCode('clipPictures', 500, 200);
</script>

<h2 id="Flipping">Flipping</h2>

<p>You can flip image sources horizontally and vertically with the <a>Picture.flip</a> property:</p>

<pre class="lang-js" id="flipPictures"><code>
const settings = { source: "images/100x65.png", margin: 2 };
diagram.add(
  new go.Part("Table")
    .add(
      new go.Picture(settings)
        .set({ column: 0, flip: go.Flip.None /* the default value */ }),
      new go.TextBlock("None (default)", { row: 1, column: 0 }),
      new go.Picture(settings)
        .set({ column: 1, flip: go.Flip.Horizontal }),
      new go.TextBlock("FlipHorizontal", { row: 1, column: 1 }),
      new go.Picture(settings)
        .set({ column: 2, flip: go.Flip.Vertical }),
      new go.TextBlock("FlipVertical", { row: 1, column: 2 }),
      new go.Picture(settings)
        .set({ column: 3, flip: go.Flip.Both }),
      new go.TextBlock("FlipBoth", { row: 1, column: 3 })
    ));
</code></pre>
<script>
  goCode('flipPictures', 600, 160);
</script>

<h2 id="CrossOriginPictures">Cross Origin Pictures</h2>

<p>
  Since Pictures are backed by HTMLImageElements, they must abide by the same Cross-origin (CORS) rules that apply to Images. If you are using images that apply
  to CORS rules, you may need to set the <a>Picture.sourceCrossOrigin</a> property to a function that returns an appropriate value. If
  <code>sourceCrossOrigin</code> is supplied, the value returned by the function is used as the value of any constructed <code>image.crossOrigin</code>.
  Example:
</p>
<pre class="lang-js"><code>
new go.Picture({
    width: 64, height: 64,
    sourceCrossOrigin: pict => "use-credentials"
  })
  .bind("source", "path")
</code></pre>
<p>
  Common values to return are "use-credentials" and "anonymous", but other situations may call for other values or conditional values. We suggest researching
  <a href="https://enable-cors.org/">cross-origin resource sharing</a> to determine what is right for your situation.
</p>
<p>
  If you are using <a>Diagram.makeImage</a>, <a>Diagram.makeImageData</a>, or <a>Diagram.makeSvg</a>, and you are seeing blank or missing images, CORS-related
  problems are the first thing to investigate.
</p>
<h2 id="UsingSVGAsPictureSource">Using SVG as a Picture source</h2>

<p>
  Almost all browsers accept SVG files as a Picture source, but in many browsers you <strong>must</strong>
  assign width and height attributes to the SVG element. These values should be integers.
</p>
<p>
  This first SVG file has a width and height specified in its SVG element, and also has its desired size set.
  It should display in most browsers:
</p>

<pre class="lang-html"><code>
&lt;svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     width="580" height="580"&gt;
  ...
</code></pre>

<pre class="lang-js" id="svg1"><code>
diagram.add(
  new go.Part()
    .add(
      new go.Picture({ width: 580, height: 580, source: "images/tiger.svg" })
    ));
diagram.scale = 0.5;
</code></pre>
<script>
  goCode('svg1', 300, 300);
</script>

<p style="color: red">
  <strong> The following SVG file does not specify width and height attributes in its SVG element,
    and as a result some browsers may not render it correctly: </strong>
</p>

<pre class="lang-html"><code>
&lt;svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
  ...
</code></pre>
<pre class="lang-js" id="svg2"><code>
diagram.add(
  new go.Part()
    .add(
      // missing width and height:
      new go.Picture({ source: "images/tiger-noWidthHeightSpecified.svg" })
    ));
diagram.scale = 0.5;
</code></pre>
<script>
  goCode('svg2', 300, 300);
</script>
