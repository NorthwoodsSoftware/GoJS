<h1>Custom Routers</h1>
<p>
  Each Link performs a very fast default computation of its desired path, its "route", based only on the properties of the Link and the properties of the port
  objects that it is connected with, as discussed in the pages on <a href="links.html#Routing">Links</a> and on
  <a href="connectionPoints.html">Link Connection Points</a>.
</p>
<p>
  GoJS rovides a way to customize link routing by allowing consideration of other Nodes and Links, with the
  <a>Router</a> class. Routers can be created and added to the Diagram's <a>Diagram.routers</a> list, and these will operate on links during updates.
</p>

<h2 id="RoutingBasics">Routing Basics</h2>
<p>
  Routers work by defining a method, <a>Router.routeLinks</a>, which takes a collection of recently recomputed link routes, plus a collection context that is
  either a Group or the Diagram. This method is called by the Diagram during the update phase after layouts are performed.
</p>
<pre class="lang-js"><code>
  class MyRouter extends go.Router {
    // links is a Set of Links that may need to be re-routed to avoid other Links
    // container is either a Group or a Diagram
    routeLinks(links, container) {
      // if container is a Group, operate on those links that are members of that Group
      // if container is a Diagram, operate on those links that are top-level (i.e. not in a Group)
    }
  }
</code></pre>
<p>
  During updates to the Diagram, GoJS does a depth-first walk of all <a>Group</a>s in the Diagram,
  starting with the leaf-most Groups, and performs their layouts if invalid.
  For each of the routers present in <a>Diagram.routers</a>, the Diagram calls <a>Router.canRoute</a>, passing it the Group.
  If that predicate returns true, it calls <a>Router.routeLinks</a>.
  Finally, the Diagram performs the <a>Diagram.layout</a> if it is invalid,
  and calls <a>Router.canRoute</a> and possibly <a>Router.routeLinks</a> with the Diagram itself.
</p>
<p class="box" style="background-color: lightgoldenrodyellow">
  Group bounds are normally affected by their member links because <a>Group.computesBoundsIncludingLinks</a> is true by default. You can set this property to
  false if you do not want or need the bounds of member links to affect the bounds of any Groups.
</p>

<h2>Simple Router Example</h2>
The sample below shows a simple use case of a <a>Router</a>, which will cause the vertical segments of links in a <a>TreeLayout</a> to be positioned at a fixed
distance from the next node in the tree. This custom router is designed to only operate on the whole <a>Diagram</a>, not individual <a>Group</a>s.
<pre class="lang-js" id="routing2"><code>
  class CustomTreeRouter extends go.Router {
    constructor(init) {
      super();
      this.name = "CustomTree";
      if (init) Object.assign(this, init);
    }

    canRoute(container) {
      if (!super.canRoute(container)) return false;
      if (container instanceof go.Diagram) return true;
      return false; // only perform routing on the whole Diagram, never on Groups
    }

    // We do not use the second `container` argument in this router, because we implemented
    // canRoute to ignore groups
    routeLinks(links, container) {
      links.each(link => {
        if (!link.isOrthogonal) return; // only applies to orthogonal links

        // assume links are going left to right
        const childX = link.getPoint(link.pointsCount - 1).x;

        const p2 = link.getPoint(2);
        const p3 = link.getPoint(3);
        if (Math.abs(p2.x - p3.x) < 0.01) { // don't route horizontal segments
          link.startRoute();
          link.setPoint(2, new go.Point(childX - 10, p2.y));
          link.setPoint(3, new go.Point(childX - 10, p3.y));
          link.commitRoute();
        }
      });
    }
  }  // end of CustomTreeRouter


  diagram.routers.add(new CustomTreeRouter());

  diagram.layout = new go.TreeLayout();

  diagram.nodeTemplate =
    new go.Node("Auto")
      .add(
        new go.Shape("RoundedRectangle", { strokeWidth: 0 })
          .bind("fill", "color"),
        new go.TextBlock({ margin: 8 })
          .bind("text", "key")
      );

  diagram.linkTemplate =
    new go.Link({ routing: go.Routing.Orthogonal })
      .add(
        new go.Shape({ strokeWidth: 1.5, stroke: '#444' })
      );

  diagram.model = new go.GraphLinksModel(
    [
      { key: "A", color: "lightblue" },
      { key: "B", color: "orange" },
      { key: "C", color: "lightgreen" },
      { key: "D", color: "pink" },
      { key: "E", color: "lightblue" },
      { key: "F", color: "orange" }
    ],
    [
      { from: "A", to: "B" },
      { from: "A", to: "C" },
      { from: "B", to: "D" },
      { from: "C", to: "E" },
      { from: "C", to: "F" }
    ]
  );

  window.toggleRouter = () => {
    diagram.commit(diag => {
      const router = diag.findRouter("CustomTree");
      if (router instanceof CustomTreeRouter) {
        router.isEnabled = !router.isEnabled;
        // this is needed due to dynamically enabling/disabling routers
        diag.links.each(link => link.invalidateRoute());
      }
    });
  }
</code></pre>
<script>
  goCode('routing2', 500, 200);
</script>
<button id="Toggle Router" onclick="toggleRouter();">Toggle Router</button>

<h2 id="AvoidsLinksRouter">Avoids Links Router</h2>
<p>
  When creating diagrams with many Links using Orthogonal or AvoidsNodes routing,
  it is common to have segments of separate links overlapping.
  GoJS provides an extension, the <a href="../api/symbols/AvoidsLinksRouter.html">AvoidsLinksRouter</a>,
  which will cause such segments to instead be routed in parallel while minimizing the number of crossings between segments.
</p>
<p>
  For a demonstration of the AvoidsLinksRouter in a diagram with many links,
  see the <a href="../samples/AvoidsLinksRouter.html">Avoids Links Router sample</a>.
</p>

<h2 id="LinkLabelRouter">Link Label Router</h2>
<p>
  When creating diagrams with many Links that have labels on them,
  it is common to have those labels sometimes overlapping each other.
  GoJS provides an extension, the <a href="../api/symbols/LinkLabelRouter.html">LinkLabelRouter</a>,
  which will cause such labels to be shifted slightly in order to reduce the overlaps.
</p>
<p>
  Although that Router does not actually modify any Link routes, it may modify the bounds of some Links,
  and it can only do so after the default routing of all Links has already taken place.
</p>
<p>
  For a demonstration of the LinkLabelRouter in a diagram with many links,
  see the <a href="../samples/LinkLabelRouter.html">Link Label Router sample</a>.
</p>