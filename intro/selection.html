
<h1>Selection</h1>
<p>
  Selection is a mechanism that provides the ability for the user to operate commands or tools on a
  subset of the <a>Part</a>s in a <a>Diagram</a>.
  GoJS provides built-in appearances and behaviors for selection.
  Although this page describes how those built-in appearances and behaviors can be customized,
  if you want a more general highlighting capability with no built-in appearances or behaviors,
  please read the page on <a href="highlighting.html">Highlighting</a>.
</p>
<p>
  Users normally select Parts manually by clicking on them and they deselect them by clicking in the background.
  This behavior is implemented by the <a>ClickSelectingTool</a>.
  Users can also deselect all Parts by pressing the Esc key.
</p>
<p>
  Users can also drag in the background in order to select the Parts that are within a rectangular area, via the <a>DragSelectingTool</a>.
  Read more about that in the Introduction to Tools at <a href="tools.html#DragSelectingTool">DragSelectingTool</a>.
</p>
<p>
  You can select parts programmatically by setting <a>Part.isSelected</a> or calling one of several
  <a>Diagram</a> methods such as <a>Diagram.select</a>, <a>Diagram.selectCollection</a>, and <a>Diagram.clearSelection</a>.
</p>
<p>
  The <a>Diagram</a> keeps a collection of selected parts, <a>Diagram.selection</a>.
  That collection is read-only -- the only way to add or remove a Part in the <a>Diagram.selection</a> collection
  is by setting its <a>Part.isSelected</a> property.
  You can limit how many parts the user may select by setting <a>Diagram.maxSelectionCount</a>.
  Prevent all selection by the user by setting <a>Diagram.allowSelect</a> to false.
  Or prevent a particular Part from being selected by setting or binding its <a>Part.selectable</a> property to false.
</p>
<p>
  You can show that a part is selected by either or both of two general techniques:
  adding <a>Adornment</a>s or changing the appearance of some of the elements in the visual tree of the selected Part.
</p>

<h2 id="SelectionAdornments">Selection Adornments</h2>
<p>
  It is common to display that a Part is selected by having it show a selection <a>Adornment</a> when the Part is selected.
  For nodes this is normally a blue rectangle surrounding the whole Node.
  This is the default behavior; if you do not want such an adornment, you can set <a>Part.selectionAdorned</a> to false.
</p>

<pre class="lang-js" id="adornmentDefault"><code>
diagram.nodeTemplate =
  new go.Node("Vertical", {
      // the location is the center of the Shape, not the center of the whole Node
      locationSpot: go.Spot.Center, locationObjectName: "ICON"
    })
    .bind("location", "loc", go.Point.parse)
    .add(
      new go.Shape({
          name: "ICON",
          width: 40, height: 40,
          fill: "gray",
          portId: ""  // the port is this Shape, not the whole Node
        })
        .bind("figure"),
      new go.TextBlock({ margin: new go.Margin(5, 0, 0, 0) })
        .bind("text")
    );

const nodeDataArray = [
  { key: 1, text: "Alpha", figure: "Club", loc: "0 0" },
  { key: 2, text: "Beta", figure: "Spade", loc: "200 50" }
];
const linkDataArray = [
  { from: 1, to: 2 }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);

diagram.commandHandler.selectAll();
</code></pre>
<script>
  goCode('adornmentDefault', 600, 150);
</script>

<p>
  By default an <a>Adornment</a> will apply to the whole <a>Node</a>.
  What if you want attention to be drawn only to the main piece of a node?
  You can accomplish that by naming that object and setting <a>Part.selectionObjectName</a> to that name.
</p>
<pre class="lang-js" id="adornmentObject"><code>
diagram.nodeTemplate =
  new go.Node("Vertical", {
      selectionObjectName: "ICON",  // added this property!
      // the location is the center of the Shape, not the center of the whole Node
      locationSpot: go.Spot.Center, locationObjectName: "ICON"
    })
    .bind("location", "loc", go.Point.parse)
    .add(
      new go.Shape({
          name: "ICON",
          width: 40, height: 40,
          fill: "gray",
          portId: ""  // the port is this Shape, not the whole Node
        })
        .bind("figure"),
      new go.TextBlock({ margin: new go.Margin(5, 0, 0, 0) })
        .bind("text")
    );

const nodeDataArray = [
  { key: 1, text: "Alpha", figure: "Club", loc: "0 0" },
  { key: 2, text: "Beta", figure: "Spade", loc: "200 50" }
];
const linkDataArray = [
  { from: 1, to: 2 }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);

diagram.selectCollection(diagram.nodes);
</code></pre>
<script>
  goCode('adornmentObject', 600, 150);
</script>
<p>
  Note how the <a>Part.selectionObjectName</a> property is similar to the <a>Part.locationObjectName</a>
  in helping to treat a node as if only one piece of it really matters.
</p>

<h3 id="CustomSelectionAdornments">Custom Selection Adornments</h3>
<p>
  If you do want a selection adornment but want something different than the standard one, you can customize it.
  Such customization can be done by setting the <a>Part.selectionAdornmentTemplate</a>.
  In this example, nodes get thick blue rounded rectangles surrounding the selected node, and links get thick blue lines
  following the selected link's path.
</p>
<pre class="lang-js" id="custom"><code>
diagram.nodeTemplate =
  new go.Node("Auto", {
      selectionAdornmentTemplate:
        new go.Adornment("Auto")
          .add(
            new go.Shape("RoundedRectangle", {
                fill: null, stroke: "dodgerblue", strokeWidth: 8
              }),
            new go.Placeholder({ margin: 1 })
          )  // end Adornment
    })
    .bind("location", "loc", go.Point.parse)
    .add(
      new go.Shape("RoundedRectangle", { fill: "lightgray" }),
      new go.TextBlock({ margin: 5 })
        .bind("text")
    );

diagram.linkTemplate =
  new go.Link({
      selectionAdornmentTemplate:
        new go.Adornment()
          .add(
            new go.Shape({ isPanelMain: true, stroke: "dodgerblue", strokeWidth: 8 }),
            new go.Shape({ toArrow: "Standard", fill: "dodgerblue", stroke: null, scale: 2.5 })
          )  // end Adornment
    })
    .add(
      new go.Shape({ strokeWidth: 2 }),
      new go.Shape({ toArrow: "Standard" })
    );

const nodeDataArray = [
  { key: 1, text: "Alpha", loc: "0 0" },
  { key: 2, text: "Beta", loc: "200 50" }
];
const linkDataArray = [
  { from: 1, to: 2 }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);

diagram.commandHandler.selectAll();
</code></pre>
<script>
  goCode('custom', 600, 100);
</script>
<p>
  Note that an <a>Adornment</a> is just a <a>Part</a>.
  Adornments for nodes must contain a <a>Placeholder</a> in their visual tree.
  The Placeholder gets positioned where the selected object is.
</p>
<p>
  Adornments for links are assumed to be panels of <a>Panel.type</a> that is <a>Panel.Link</a>.
  Hence the main element may be a <a>Shape</a> that gets the geometry of the selected Link's path shape,
  and the other elements of the adornment may be positioned on or near the segments of the link route just as for a regular <a>Link</a>.
</p>

<h3 id="MoreComplexAdornments">More Complex Adornments</h3>
<p>
  The custom <a>Adornment</a> for a <a>Node</a> need not be only a simple <a>Shape</a> outlining the selected node.
  Here is an adornment that adds a button to the adornment which inserts a node and a link to that new node.
</p>
<pre class="lang-js" id="complex"><code>
function addNodeAndLink(e, b) {
  // take a button panel in an Adornment, get its Adornment, and then get its adorned Node
  const node = b.part.adornedPart;
  // we are modifying the model, so conduct a transaction
  const diagram = node.diagram;
  diagram.startTransaction("add node and link");
  // have the Model add the node data
  const newnode = { text: "N" + diagram.model.nodeDataArray.length };
  diagram.model.addNodeData(newnode);
  // locate the node initially where the parent node is
  diagram.findNodeForData(newnode).location = node.location;
  // and then add a link data connecting the original node with the new one
  const newlink = { from: node.data.key, to: newnode.key };
  diagram.model.addLinkData(newlink);
  // finish the transaction -- will automatically perform a layout
  diagram.commitTransaction("add node and link");
}

diagram.nodeTemplate =
  new go.Node("Auto", {
      selectionAdornmentTemplate:
        new go.Adornment("Spot")
          .add(
            new go.Panel("Auto")
              .add(
                // this Adornment has a rounded blue Shape around the selected node
                new go.Shape("RoundedRectangle", {
                  fill: null, stroke: "dodgerblue", strokeWidth: 3,
                  spot1: go.Spot.TopLeft, spot2: go.Spot.BottomRight
                }),
                new go.Placeholder()
              ),
            // and this Adornment has a Button to the right of the selected node
            go.GraphObject.build("Button", {
                alignment: go.Spot.Right, alignmentFocus: go.Spot.Left,
                click: addNodeAndLink
              })  // define click behavior for Button in Adornment
              .add(
                new go.TextBlock("ADD",  // the Button content
                    { stroke: "blue", font: "bold 8pt sans-serif" })
              )
          )  // end Adornment
    })
    .add(
      new go.Shape("RoundedRectangle", { fill: "lightgray" }),
      new go.TextBlock({ margin: 5 })
        .bind("text")
    );

diagram.layout = new go.TreeLayout();

const nodeDataArray = [
  { key: 1, text: "Alpha" },
  { key: 2, text: "Beta" }
];
const linkDataArray = [
  { from: 1, to: 2 }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);

diagram.select(diagram.findNodeForKey("Beta"));
</code></pre>
<script>
  goCode('complex', 600, 200);
</script>
<p>Select any node and click the "ADD" button. Note how the diagram is automatically laid out as a tree.</p>

<h3 id="DataBinding">Data Binding</h3>
<p>
  Like all <a>Part</a>s, <a>Adornment</a>s support data binding. If the adorned Part has a data binding (i.e. if <a>Part.data</a> is non-null), all adornments
  for that part will also be bound to the same data object.
</p>
<pre class="lang-js" id="binding"><code>
diagram.nodeTemplate =
  new go.Node("Auto", {
      selectionAdornmentTemplate:
        new go.Adornment("Auto")
          .add(
            new go.Shape("Diamond", { fill: null, stroke: "dodgerblue", strokeWidth: 6 })
              .bind("stroke", "color"),
            new go.Placeholder()
          )  // end Adornment
    })
    .bind("location", "loc", go.Point.parse)
    .add(
      new go.Shape("RoundedRectangle", { fill: "lightgray", strokeWidth: 2 })
        .bind("stroke", "color"),
      new go.TextBlock({ margin: 5 })
        .bind("text")
    );

const nodeDataArray = [
  { key: 1, text: "Alpha", loc: "0 0", color: "blue" },
  { key: 2, text: "Beta", loc: "200 50", color: "red" }
];
const linkDataArray = [
  { from: 1, to: 2 }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);

diagram.selectCollection(diagram.nodes);
</code></pre>
<script>
  goCode('binding', 600, 150);
</script>
<p>
  Notice how each Adornment has the same color as the selected node's <code>data.color</code>.
</p>

<h2 id="SelectionAppearanceChanges">Selection Appearance changes</h2>
<p>
  Adding a selection adornment is not the only way to indicate visually that a <a>Part</a> is selected.
  You can also modify the appearance of one or more objects in your Part.
</p>
<p>
  One way to do this is with data binding. Here we data bind the <a>Shape.fill</a> to the <a>Part.isSelected</a> property
  with a converter function that converts the boolean value to a color string or brush.
  We also turn off the regular rectangular blue selection adornment.
</p>
<pre class="lang-js" id="isSelected"><code>
diagram.nodeTemplate =
  new go.Node("Auto", { selectionAdorned: false })  // don't bother with any selection adornment
    .bind("location", "loc", go.Point.parse)
    .add(
      new go.Shape("RoundedRectangle", { fill: "lightgray", strokeWidth: 2 })
        // when this Part.isSelected changes value, change this Shape.fill value:
        .bindObject("fill", "isSelected", sel => {
            if (sel) return "cyan"; else return "lightgray";
          }), // The object named "" is the root visual element, the Node itself
      new go.TextBlock({ margin: 5 })
        .bind("text")
    );

const nodeDataArray = [
  { key: 1, text: "Alpha", loc: "0 0", color: "blue" },
  { key: 2, text: "Beta", loc: "200 50", color: "red" }
];
const linkDataArray = [
  { from: 1, to: 2 }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);

diagram.select(diagram.findNodeForKey(2));
</code></pre>
<script>
  goCode('isSelected', 600, 150);
</script>
<p>
  Here the "Beta" node is selected initially.
  Now when you select a node its background color changes to cyan.
</p>

<p>
  More generally you can execute code to modify the Part when <a>Part.isSelected</a> has changed value.
  In this example we will have the same side effects as the previous example.
</p>
<pre class="lang-js" id="selectionChanged"><code>
function onSelectionChanged(node) {
  const icon = node.findObject("ICON");
  if (icon !== null) {
    if (node.isSelected)
      icon.fill = "cyan";
    else
      icon.fill = "lightgray";
  }
}

diagram.nodeTemplate =
  new go.Node("Auto", {
      selectionAdorned: false,  // don't bother with any selection adornment
      selectionChanged: onSelectionChanged
    })
    .bind("location", "loc", go.Point.parse)
    .add(
      new go.Shape("RoundedRectangle", { fill: "lightgray", strokeWidth: 2 })
        // when this Part.isSelected changes value, change this Shape.fill value:
        .bindObject("fill", "isSelected", sel => {
            if (sel) return "cyan"; else return "lightgray";
          }), // The object named "" is the root visual element, the Node itself
      new go.TextBlock({ margin: 5 })
        .bind("text")
    );

const nodeDataArray = [
  { key: 1, text: "Alpha", loc: "0 0", color: "blue" },
  { key: 2, text: "Beta", loc: "200 50", color: "red" }
];
const linkDataArray = [
  { from: 1, to: 2 }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);

diagram.select(diagram.findNodeForKey(2));
</code></pre>
<script>
  goCode('selectionChanged', 600, 150);
</script>
<p>
  This basically has the same effect as the <a>GraphObject.bindObject</a> binding of the previous example,
  but the possible changes you could make to that node are much greater and probably simpler than trying to use Bindings.
</p>
<p>
  There are some restrictions on what you can do in such an event handler:
  you should not select or deselect any parts, and you should not add or remove any parts from the diagram.
</p>
